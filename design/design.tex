\chapter{Design}
\label{chapt:design}
This chapter presents the design of MultiChain and how it was implemented.
The first thing that will be introduced is how MultiChain is implemented within Tribler
to outline the context of the design and implementation.
The contents of blocks are presented and how they form chains in MultiChain.
We will cover the creation of blocks and the multiple implications of the chosen design.
We will explain how MultiChain adresses the freeriding problem.
Additional pheripheral systems that work with MultiChain are also explained.

Tribler uses communities to add functionalities to peers.
New communities are packaged into new Tribler versions.
These versions are downloaded by peers.
A community provides a set of messages and endpoints for other peers.
The community can communicate with the endpoints of other peers as well and send a message to these endpoints.
Other peers are automatically discovered using Dispersy.
Examples of communities are the TunnelCommunity that adds functionality to download anonymously\cite{Plak-anonymous}\cite{tanaskoski-anonymous}
or the AllChannelCommunity to distribute torrent files.
Our system will be implemented by adding a new community to Tribler.

The MultiChain community can be run standalone,
but its main use is to integrate with Tribler and track up and download amounts for torrents.
It aims to replace the current reputation system Bartercast in the future.

\section{Datastructure design}
In this section we wil describe the design of the chains inside MultiChain.
We will first describe the contents of a single block.
Next, we will explain how blocks are chained together for a single peer.
These chains are intertwined and we will clarify this entanglement.
Finally, we will describe how the blocks provide security against tampering.

\input{design/bookkeeping.tex}
\input{design/scalable-reciprocity.tex}
\input{design/entanglement.tex}
\input{design/signatures.tex}

\section{Block creation protocol}
\label{design:block_creation}
In this section we will explain how blocks can be created with a simple design
that will limit and expose freeriding.
Afterwards, we will explain a fundamental problem with creating blocks in an asynchronous system.
This problem is present in the simple design
and we will describe how MultiChain deals with this problem.

\input{design/exchanging_blocks.tex}
\input{design/limitingfreeriding.tex}
\input{design/synchronizationproblem.tex}

\input{design/mutual_exclusion.tex}

\input{design/persistence.tex}

\input{design/blocksize.tex}

\input{design/integration.tex}
\input{design/crawler.tex}
\input{design/anonymity.tex}
