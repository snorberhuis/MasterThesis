\section{Block creation}

\subsection{Exchanging signatures protocol}
Nodes will exchange signatures on a common payload that contains the reputation metrics.
A simple design would be to let the initiator node $A$ send a payload to $B$.
The payload contains a claim on an increase of reputation and a signature made by $A$.
If the node $B$ accepts the claim of the increase in reputation,
then he will add his own signature to the claim.
The payload and the two signatures are now a new block.
The block will be added to the current chain of node $B$ 
and the block will be sent to node $A$ to be appended to the chain of $A$.

This simple design does have one major problem.
It can never be decided in an asynchronous communication model
if the other node will ever respond and when it will respond.
The proposed block by $A$ only needs an interaction of $B$ to be finished
and $B$ can finish this transaction at anytime that he decides upon.

But the future block contains an immutable hash pointer
to the previous block in the chain of node $A$.
So while this transaction for a potential block is outstanding,
node $A$ cannot interact with any other node $C$ to create a different block.
If it would, then if $B$ could ultimately respond and a branch with different blocks
would be created for the chain of $A$.
This simple design introduces therefor an external response dependency problem.

The to-be-designed system has to be fault tolerant to 
common problems in a challenged network, such as node failure.
A second design goal is to be able to process transactions quickly and on a large scale.
These design goals prevent the adaption of a simple design that will halt until node $B$ responds.
There are several possible designs that are a solution to this problem.

\subsubsection{Fair exchange signature scheme}
A fair exchange signature scheme (FESS) allows two players to exchange digital signatures in a fair way.
Fair constitutes that no player can take advantage of the other.
Either both players receive each others signature or no player receives the other's signature.
It is infeasible for a node to acquire a signature without giving up their own signature.\cite{asokan-fairexchange}.
A FESS could be implement for the fair creation of the block.

But all known current FESSs use a trusted third party (TTP) at some point\cite{asokan-fairexchange}.
Some schemes exist that are optimistic and will only need a TTP to resolve conflicts.
But any TTP will not adhere to the Tribler philosphy 
of being a truly fully distributed peer-to-peer system.
The TTP will introduce a single point of trust and a scalability bottleneck.

\subsubsection{Reverse repairing of chain}
Another potential solution would be to rework part of the chain.
The creation of block could be deemed to have failed by node $A$.
If at a later point the block is still created by $B$,
then this situation can be handled by node $A$ in two possible ways.

The block could be reworked back into the chain.
This would require every hash pointer to be updated afterwards.
If these hash pointers are modified, then the signatures are invalid.
Every signature would have to be renewed and requested at every node.
This can become unscalable if nodes needs to rework many blocks and can clog the system.
These nodes can possible no longer respond and would result in new invalid blocks.

\subsubsection{Half signed blocks}
The chosen solution is to keep it simple and allow for inconsistencies between the chains of $A$ and $B$.
It will be shown that if an inconsistency does occur this is in favor of $A$.

When node $A$ sends a signature request to $B$,
then $A$ will be optimistic and will wait for $B$ for a timeout period.
During this time $A$ will not interact with another node $C$.
But if $A$ does not have to interact with node $C$ after the timeout period,
then $A$ will still accept a response of $B$.
There are three potential scenario's of what will happen to the message.

\begin{enumerate}
\item
In the normal situation node $B$ will respond in time to the message.
$B$ will send back the message
and both $A$ and $B$ will have added the same block in their own chains.
This situation also occurs if $A$ has timed out,
but has not yet interacted with another node $C$.

\item
Node $B$ can be malicious or simply have failed and $B$ will never respond.
Node $A$ will timeout and can continue interacting with other nodes $C$.
Next to this, node $A$ will have to decide how to react upon $B$ not responding.
A possibility would be to stop helping $B$.

\item
The response of $B$ can also be late.
After $B$ has received the request by $A$,
$B$ will create a block and adds this block to his chain.
$B$ will send his response to $A$,
but the message will arrive too late at $A$.
$A$ will ignore the message and not add the block to his chain,
\end{enumerate}

The last scenario is the most complex and requires additional clarification.
$A$ initiates the signature request and therefor the block will be favourable for his reputation.
Because this is a reputation system, this inconsistency is an allowable comprimise.
In a currency system, this comprimise would not be allowable.

$A$ can not later append the late block from $B$,
because the previous hash of $A$ will be used in a new block describing an interaction with $C$.
The late block demonstrates 

The design is scalable as it will not block too long waiting for a failed node 
and will try to interact as fast as possible with other nodes.
A small grace period can be used to allow node $B$ to have enough time to respond in a normal manner.
No trusted third party is introduced so a distributed design is achieved.

\subsection{Dispersy: implementation of signature exchange}
Dispersy is middleware for data dissemination in a network.
Dispersy is used heavily within Tribler
and is also the core library MultiChain has been build upon.
Dispersy can also be used to exchange data between two specific nodes.
Dispersy is used to exchange messages between nodes implementing MultiChain.

Within Dispersy functionality was already build to create a message, sign the message
and request multiple nodes to also provide their signature on this message.
This existing functionality could be used by MultiChain to exchange signatures
between Alice and Bob for the creating of a new block.

Alice would initiate a message, insert her data into this message, sign the message, and send this message to Bob.
The functionality would allow Bob to accept the message and provide his signature or
modify the message and provide his signature.

Only Bob knows the hash of his head node, and the total up and total download metrics.
So Bob will always modify the message and insert his own data in the message.
But this would invalidate the signature of Alice,
because the signature of Alice was also placed on the empty part of the message.

After Bob returns the message,
Alice would have to resign the message.
But Bob also needs this valid signature from Alice before he can add the block to his own chain.
So Alice would need to send a third message to with the new, valid signature back to Bob.

But the full signature exchange can be achieved within two messages.
Alice can only make valid claims about and have authority over the interaction between her and Bob.
So she does not need to sign the data containing the previous hash and the total up and down of Bob.
This property allows Bob to append his own data to that of Alice.
Alice's signature would not become invalid.

Functionality was added that allows to append data in a signature request.
Alice creates a message to Bob, but only signs her data.
Bob inserts his data upon arrival and signs everything.
Bob saves this message as a block to his own chain
and sends the message back to Alice.
Upon arrival Alice can also convert the message to a new block and add this to her own chain.
Now only two messages are between Alice and Bob are necessary.

\section{Irrevocable Proof-of-Help}
Digital signatures have the property to be non-repudiable of origin.\cite{VanderLubbe-crypto}.
After signing a message the signer cannot later deny providing his signature.
Only in the possesion of a secret key can a signature be made,
so only the signer could have made the signature.
This is assuming the secret key was not comprimised at the time of signing.

This property results in that after creating a block
both participants can no longer deny involvement in that block.
Because they cannot repudiate their own signature
and the act of creating signature needs a conscious decision denoting approval of the claim of help.
The blocks become irrevocable proofs-of-help.

\section{Publicly known free-riding}
The system will make a node's share ratio publicly accessibly,
but it will expose and limit freeriding in several other ways.

The window of potential freeriding is chosen by the willingness of seeders to be altruistic.
Because the creation of blocks is driven by seeders,
downloaders cannot postpone creation of blocks and continue freeriding.
If downloaders does not participate in block creation,
then uploading to them will stop.

Downloaders cannot repudiate downloading.
For they granted their signature to a block containing information about the amount that they downloaded.
A freerider cannot try to hide his freeriding afterwards.
